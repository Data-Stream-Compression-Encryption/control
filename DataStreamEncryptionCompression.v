
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DataStreamEncryptionCompression(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// LCD //////////
	LCD_BLON,
	LCD_DATA,
	LCD_EN,
	LCD_ON,
	LCD_RS,
	LCD_RW,

	//////////// USB 2.0 OTG //////////
	OTG_ADDR,
	OTG_CS_N,
	OTG_DACK_N,
	OTG_DATA,
	OTG_DREQ,
	OTG_FSPEED,
	OTG_INT,
	OTG_LSPEED,
	OTG_RD_N,
	OTG_RST_N,
	OTG_WE_N,

	//////////// SDRAM //////////
	DRAM_ADDR,
	DRAM_BA,
	DRAM_CAS_N,
	DRAM_CKE,
	DRAM_CLK,
	DRAM_CS_N,
	DRAM_DQ,
	DRAM_DQM,
	DRAM_RAS_N,
	DRAM_WE_N,

	//////////// Flash //////////
	FL_ADDR,
	FL_CE_N,
	FL_DQ,
	FL_OE_N,
	FL_RST_N,
	FL_RY,
	FL_WE_N,
	FL_WP_N 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY //////////
input 		     [3:0]		KEY;

//////////// SW //////////
input 		    [17:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// LCD //////////
output		          		LCD_BLON;
inout 		     [7:0]		LCD_DATA;
output		          		LCD_EN;
output		          		LCD_ON;
output		          		LCD_RS;
output		          		LCD_RW;

//////////// USB 2.0 OTG //////////
output		     [1:0]		OTG_ADDR;
output		          		OTG_CS_N;		// Chip Select
output		     [1:0]		OTG_DACK_N;
inout 		    [15:0]		OTG_DATA;		// Data to write
input 		     [1:0]		OTG_DREQ;
inout 		          		OTG_FSPEED;		// Full Speed
input 		     [1:0]		OTG_INT;			// Interrupt
inout 		          		OTG_LSPEED;		// Low Speed
output		          		OTG_RD_N;
output		          		OTG_RST_N;
output		          		OTG_WE_N;

//////////// SDRAM //////////
output		    [12:0]		DRAM_ADDR;
output		     [1:0]		DRAM_BA;
output		          		DRAM_CAS_N;
output		          		DRAM_CKE;
output		          		DRAM_CLK;
output		          		DRAM_CS_N;
inout 		    [31:0]		DRAM_DQ;
output		     [3:0]		DRAM_DQM;
output		          		DRAM_RAS_N;
output		          		DRAM_WE_N;

//////////// Flash //////////
output		    [22:0]		FL_ADDR;
output		          		FL_CE_N;
inout 		     [7:0]		FL_DQ;
output		          		FL_OE_N;
output		          		FL_RST_N;
input 		          		FL_RY;
output		          		FL_WE_N;
output		          		FL_WP_N;


//=======================================================
//  REG/WIRE declarations
//=======================================================

wire clk;
wire rst;

wire go;
wire ramValid;
wire w_rn;
wire [12:0] address;
wire [63:0] dataToRead;
wire [63:0] dataToWrite;
wire [63:0] fromTest;

/*
reg go;
wire ramValid;
reg w_rn;
reg [12:0] address;
wire [63:0] dataToRead;
reg [63:0] dataToWrite;
wire [63:0] fromTest;
*/

// DSEC module signals
wire dsec_out_valid;
wire dsec_in_valid;
wire dsec_rdy;
wire dsec_out_rcvd;

wire key_config;
wire error;
//

// Hex display data 
reg [63:0] tempData;
//

//=======================================================
//  Structural coding
//=======================================================

assign clk = CLOCK_50;
assign rst = KEY[0];



mem_con u1(.clk(clk),.rst(rst),.dram_addr(DRAM_ADDR), .dram_ba(DRAM_BA), .dram_cas_n(DRAM_CAS_N), .dram_cke(DRAM_CKE), .dram_clk(DRAM_CLK), .dram_cs_n(DRAM_CS_N), .dram_dq(DRAM_DQ), .dram_dqm(DRAM_DQM), .dram_ras_n(DRAM_RAS_N), .dram_we_n(DRAM_WE_N), .dataToWrite(dataToWrite), .dataToRead(dataToRead), .address(address), .w_rn(w_rn), .go(go), .valid(ramValid),.led(LEDR[9:0]));
test_con u2(.clk(clk),.rst(rst), .address(address), .w_rn(w_rn), .go(go), .memValid(ramValid), .dsec_out_valid(dsec_out_valid), .dsec_in_valid(dsec_in_valid), .dsec_rdy(dsec_rdy),.key_config(key_config),  .out_rcvd(dsec_out_rcvd) , .fromTest(fromTest) , .dataToRead(dataToRead) ,  .ledr(LEDR[17:10]));
dsec u3(.clk(clk),.rst(rst),.data_in(fromTest),.key_config(key_config),.in_valid(dsec_in_valid),.out_rcvd(dsec_out_rcvd),.rdy(dsec_rdy),.data_out(dataToWrite),.error(error),.out_valid(dsec_out_valid));



reg myLED0,myLED1,myLED2,myLED3,myLED4,myLED5,myLED6,myLED7;
assign LEDG[0] = myLED0;
assign LEDG[1] = myLED1;
assign LEDG[2] = myLED2;
assign LEDG[3] = myLED3;
assign LEDG[4] = myLED4;
assign LEDG[5] = myLED5;
assign LEDG[6] = myLED6;
assign LEDG[7] = myLED7;



/*
//
always@(posedge CLOCK_50, negedge KEY[0])begin
	if(~KEY[0]) begin
		dataToWrite <= 64'hdeadbeefb00b1e51;
		go<=1'b1;
		address <= 13'd0;
		w_rn <= 1'b1;
		myLED0 <= 1'b0;
		tempData <= 64'd0;
	end else if(ramValid) begin
		dataToWrite <= 64'hdeadbeefb00b1e51;
		go<=1'b0;
		address <= 13'd0;
		w_rn <= 1'b0;
		myLED0 <= 1'b1;
		tempData <= dataToRead;
	end else begin
		dataToWrite <= 64'hdeadbeefb00b1e51;
		go <= go;
		address <= 13'd0;
		w_rn <= w_rn;
		tempData <= tempData;
	end
		
end
//
*/

/*
reg [4:0] seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7;	
	
SevenSegmentDisplayDriver s1(.d(seg0), .seg(HEX0));
SevenSegmentDisplayDriver s2(.d(seg1), .seg(HEX1));
SevenSegmentDisplayDriver s3(.d(seg2), .seg(HEX2));
SevenSegmentDisplayDriver s4(.d(seg3), .seg(HEX3));
SevenSegmentDisplayDriver s5(.d(seg4), .seg(HEX4));
SevenSegmentDisplayDriver s6(.d(seg5), .seg(HEX5));
SevenSegmentDisplayDriver s7(.d(seg6), .seg(HEX6));
SevenSegmentDisplayDriver s8(.d(seg7), .seg(HEX7));

//assign ramData = (ramValid)? 64'hzzzzzzzzzzzzzzzz : 64'hdeadbeefb00b1e50;

always@(posedge CLOCK_50, negedge KEY[0])begin
	if(~KEY[0]) begin
		seg0 <= 5'b0;
		seg1 <= 5'b0;
		seg2 <= 5'b0;
		seg3 <= 5'b0;
		seg4 <= 5'b0;
		seg5 <= 5'b0;
		seg6 <= 5'b0;
		seg7 <= 5'b0;
	end else if(SW[0]) begin
		seg0 <= {1'b0,tempData[3:0]};
		seg1 <= {1'b0,tempData[7:4]};
		seg2 <= {1'b0,tempData[11:8]};
		seg3 <= {1'b0,tempData[15:12]};
		seg4 <= {1'b0,tempData[19:16]};
		seg5 <= {1'b0,tempData[23:20]};
		seg6 <= {1'b0,tempData[27:24]};
		seg7 <= {1'b0,tempData[31:28]};
	end else begin
		seg0 <= {1'b0,tempData[35:32]};
		seg1 <= {1'b0,tempData[39:36]};
		seg2 <= {1'b0,tempData[43:40]};
		seg3 <= {1'b0,tempData[47:44]};
		seg4 <= {1'b0,tempData[51:48]};
		seg5 <= {1'b0,tempData[55:52]};
		seg6 <= {1'b0,tempData[59:56]};
		seg7 <= {1'b0,tempData[63:60]};	
	end
end
*/


endmodule
